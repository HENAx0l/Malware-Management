## File Composition
- **attack_space_management.py:** Implementation of our method. The current version has not been refactored, contains some errors, and has some unremoved modification traces.
- **MalConv_secml.py:** Integration of our method into the MalConv model, suitable for black-box attacks and white-box attacks on secml_malware.
- **MalConv2_secml.py, LowMemConv_secml.py:** Integration of our method into MalConv2 models, suitable for black-box attacks (white-box attacks not yet adapted) on secml_malware.

## How to Use
For example, performing a black-box fulldos attack:

```python
from src.MalConv_secml import MalConv
from secml_malware.attack.blackbox.c_blackbox_header_problem import CBlackBoxHeaderEvasionProblem
from secml_malware.models import CClassifierEnd2EndMalware
from secml_malware.attack.blackbox.ga.c_base_genetic_engine import CGeneticAlgorithm
import torch
import numpy as np
from secml.array import CArray

mode = 'delete'
malconv = MalConv(window_size=500, stride=500, mode=mode)
malconv.load_state_dict(torch.load(f'model/{mode}_epoch_3.checkpoint')['model_state_dict'])
classifier = CClassifierEnd2EndMalware(malconv)
classifier._classes = np.array([0, 1])
classifier._n_features = 2 ** 21
black_box_attack = CBlackBoxHeaderEvasionProblem(
    CEnd2EndWrapperPhi(classifier),
    optimize_all_dos=True,
    iterations=100,
    population_size=50,
)
engine = CGeneticAlgorithm(black_box_attack)

# Load malicious file, refer to https://github.com/pralab/secml_malware/blob/master/blackbox_tutorial.ipynb for the third step

for sample, label in zip(X, y):
    y_pred, adv_score, adv_ds, f_obj = engine.run(sample, CArray(label[1]))
    print(engine.confidences_)
```
 If you want to use our method only for file processing:
```python
with open(to_load, 'rb') as f:
    m = Management(f.read())
    m.scan()
    # Time stamp and attack space size after scanning non-attack space
    print(m.multiple_data) 
    #Returning the byte array processed with the specified mode
    x = m.bytearray_management(mode)
    
return x[:max_len]
```