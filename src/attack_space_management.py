import pefile,time,struct
GUIAPI=["QTGUI","QT5","QT6","GDI32","D3D","RESOURCE","MFC","COLOR"]
ALGTH=0.1
ALGP=10
RERCTH=4096
DATATH=2048
# MIN_DIFF=0x20 
# MAX_OFFSET=0xE9 
# FIX_HEADER=bytearray(b'\x4D\x5A\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xFF\xFF\x00\x00\xB8\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x0E\x1F\xBA\x0E\x00\xB4\x09\xCD\x21\xB8\x01\x4C\xCD\x21\x54\x68\x69\x73\x20\x70\x72\x6F\x67\x72\x61\x6D\x20\x63\x61\x6E\x6E\x6F\x74\x20\x62\x65\x20\x72\x75\x6E\x20\x69\x6E\x20\x44\x4F\x53\x20\x6D\x6F\x64\x65\x2E\x0D\x0D\x0A\x24\x00\x00\x00\x00\x00\x00\x00')
def ingui(s):
    for api in GUIAPI:
        if api in s.upper():
            return True
    return False
def diff_count(bytearray1 ,bytearray2):
    return sum(a != b for a, b in zip(bytearray1, bytearray2))
class timeused:
    def __init__(self):
        self.timenow=time.perf_counter()
        self.times=[]
    def mark(self):
        self.times.append((time.perf_counter()-self.timenow)*1000)
        self.timenow=time.perf_counter()
class Management:
    """
    Load from PE bytes
    
    Example:
    ```python
    with open(to_load, 'rb') as f:
        m=Management(f.read())
        m.scan()
        print(self.multiple_data)# Time stamp and attack space size after scanning non-attack space
        x=m.bytearray_management('delete')
    return x[:max_len]
    ```python
    """
    def __init__(self,pe_data):
        """
        Initializes an instance of the class with the given `pe_data`.

        Parameters:
            pe_data (bytes): The PE data to be assigned to the instance.

        Returns:
            None
        """
        try:
            self.pe_data=pe_data
            self.pe=pefile.PE(data=pe_data,fast_load=True)
            self.nas={0:len(pe_data)}
        except:
            self.nas=None
        self.multiple_data=[0,0,0,0,0,0,0,0]
    def __del__(self):
        try:
            self.pe.close()
        except:
            pass
    def _isrerc(self):
            try:
                for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                    if ingui(entry.dll.decode().rstrip('\x00')):
                        return True
                    for imp in entry.imports:
                        if imp.name and ingui(imp.name.decode('utf-8')):
                            return True
                return False
            except:
                return False
    def _reallocation(self,i):
        start=self.pe.get_offset_from_rva(self.pe.sections[i].VirtualAddress)
        alg=int(self.pe.OPTIONAL_HEADER.FileAlignment*ALGTH)
        end=start+self.pe.sections[i].SizeOfRawData-1
        if end>len(self.pe_data):
            end=len(self.pe_data)-1
        if any(self.pe_data[end-alg:end]):
            return int(self.pe.sections[i].SizeOfRawData-ALGTH*ALGP*self.pe.OPTIONAL_HEADER.FileAlignment)
        else:
            while alg<self.pe.OPTIONAL_HEADER.FileAlignment:
                alg+=1
                if self.pe_data[end-alg]!=0:
                    break
            return self.pe.sections[i].SizeOfRawData-alg


    def _findsection(self,VirtualAddress):
        for i in range(len(self.pe.sections)):
            if VirtualAddress>=self.pe.sections[i].VirtualAddress and VirtualAddress<=self.pe.sections[i].VirtualAddress+self.pe.sections[i].SizeOfRawData:
                return i
        return None
    def _isrealsection(self,i):
        # Parse the section to determine whether it is a real section.
        if self.pe.sections[i].Characteristics&pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_EXECUTE']:
            return False
        return True
    def _findexecsection(self,execs):
    
        try:
            EntryPoint=self.pe.get_offset_from_rva(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint)
            find=self._findsection(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint)
            if find:
            #if pe.PE_TYPE==pefile.OPTIONAL_HEADER_MAGIC_PE:
                if 0xE9 in self.pe_data[EntryPoint:EntryPoint+5]:
                    if find and find in execs:
                        execs.remove(find)
                        return execs
                return [find]
            else:
                return execs
        except:
            return execs
    def _realdatasection(self,exec_data,i):
        if self.pe.sections[i].SizeOfRawData>DATATH and struct.pack('<I' if self.pe.PE_TYPE == pefile.OPTIONAL_HEADER_MAGIC_PE else '<Q', self.pe.sections[i].VirtualAddress)  not in exec_data:
            return False
        return True
    # def _findrealexecsection(self,i):
    #     try:
    #         start=self.pe.get_offset_from_rva(self.pe.sections[i].VirtualAddress)
    #         end=start+self.pe.sections[i].SizeOfRawData
    #         if end>len(self.pe_data):
    #             end=len(self.pe_data)
    #         j=0
    #         while j<ALGTH*ALGP*self.pe.OPTIONAL_HEADER.FileAlignment:
    #             j+=1
    #             if 0xc3 ==self.pe_data[end-j]:
    #                 break
    #         return end-start-j
    #     except:
    #         return self.pe.sections[i].SizeOfRawData
    def _scanning(self):
        times=[]
        mytime=timeused()
        #dos header and stub 
        #if self.pe.DOS_HEADER.e_lfanew>MAX_OFFSET or (self.pe.DOS_HEADER.e_lfanew<len(FIX_HEADER) and diff_count(self.pe_data[0:self.pe.DOS_HEADER.e_lfanew],FIX_HEADER[0:self.pe.   DOS_HEADER.e_lfanew])>MIN_DIFF) or (self.pe.DOS_HEADER.e_lfanew>len(FIX_HEADER) and diff_count(self.pe_data[0:len(FIX_HEADER)],FIX_HEADER)>MIN_DIFF)  :
        ret={0:2}
        ret[60]=4
        #else:
        #    ret={0:self.pe.DOS_HEADER.e_lfanew}
        besection=[]
        #Resource section
        mytime.mark()
        if self.pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].VirtualAddress!=0:
            rercnum=self._findsection(self.pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].VirtualAddress)
            if rercnum and (self.pe.sections[rercnum].SizeOfRawData<RERCTH or self._isrerc()):
                besection.append(rercnum)
        mytime.mark()
        #Sections in Image Data Directory
        for i in range(self.pe.OPTIONAL_HEADER.NumberOfRvaAndSizes):
            if self.pe.OPTIONAL_HEADER.DATA_DIRECTORY[i].VirtualAddress!=0 :
                s=self._findsection(self.pe.OPTIONAL_HEADER.DATA_DIRECTORY[i].VirtualAddress)
                if s and s not in besection and self._isrealsection(s):
                    besection.append(s)
        mytime.mark()
        #Executable section
        exec_section=[]
        exec_bytes=bytearray()
        for i in range(len(self.pe.sections)):
            if i not in besection and self.pe.sections[i].Characteristics&pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_EXECUTE'] and not self.pe.sections[i].Characteristics&pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_DISCARDABLE']:
               exec_section.append(i)
        if len(exec_section)==0:
            exnum=self._findsection(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint)
            if exnum not in besection:
                exec_section.append(exnum)
            else:
                exec_bytes+=self.pe_data[self.pe.get_offset_from_rva(self.pe.sections[exnum].VirtualAddress):self.pe.get_offset_from_rva(self.pe.sections[exnum].VirtualAddress)+self.pe.sections[exnum].SizeOfRawData]
        elif len(exec_section)!=1:
            exec_section=self._findexecsection(exec_section)
        besection+=exec_section
        # for i in exec_section:
        #     if i is not None:
        #         execlen=findrealexecsection(pe,pe_data,i)
        #         ret[pe.get_offset_from_rva(pe.sections[i].VirtualAddress)]=execlen
        #         exec_bytes+=pe_data[pe.get_offset_from_rva(pe.sections[i].VirtualAddress):pe.get_offset_from_rva(pe.sections[i].VirtualAddress)+execlen]
        mytime.mark()
        #data section
        data_section=[]
        for i in range(len(self.pe.sections)):
            if self.pe.sections[i].Characteristics==3221225536 and not self.pe.sections[i].Characteristics&pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_DISCARDABLE'] and i not in besection and i not in exec_section:
                data_section.append(i) 
        if len(data_section)==1:
            besection.append(data_section[0])
        elif len(data_section)>1:
            for i in data_section:
                if self._realdatasection(exec_bytes,i):
                    besection.append(i)
        mytime.mark()
        #realsection
        for i in besection:
            try:
                if i!=None and self.pe.sections[i] and self.pe.get_offset_from_rva(self.pe.sections[i].VirtualAddress)!=0:
                    ret[self.pe.get_offset_from_rva(self.pe.sections[i].VirtualAddress)]=self._reallocation(i)
            except:
                pass
        mytime.mark()
        #Optional header
        if self.pe.PE_TYPE==pefile.OPTIONAL_HEADER_MAGIC_PE:
            ret[self.pe.DOS_HEADER.e_lfanew]=0xf8+self.pe.FILE_HEADER.NumberOfSections*0x28
        else:
            ret[self.pe.DOS_HEADER.e_lfanew]=0x108+self.pe.FILE_HEADER.NumberOfSections*0x28
        return ret,mytime.times
    
    def bytearray_management(self,mode='delete'):
        """
        Generate a modified bytearray based on the given mode.

        Args:
            mode (str, optional): The mode to determine how the modification is performed. Defaults to 'delete'.

        Returns:
            bytearray: The modified bytearray.
        """
        if self.nas==None:
            return self.pe_data
        lasti=0
        ret=bytearray()
        if mode=='delete':
            for (k,v) in dict(self.nas).items():
                ret+=self.pe_data[k:k+v]
        elif mode=='flip':
            for (k,v) in dict(self.nas).items():
                ret.extend([x ^ 0xff for x in self.pe_data[lasti:k]])
                ret.extend(self.pe_data[k:k+v])
                lasti=k+v
            if len(self.pe_data)>lasti:
                ret.extend([x ^ 0xff for x in self.pe_data[lasti:len(self.pe_data)]])
        elif mode=='foz':
            for (k,v) in dict(self.nas).items():
                ret.extend([0 if x == 0 else x ^ 0xff for x in self.pe_data[lasti:k]])
                ret.extend(self.pe_data[k:k+v])
                lasti=k+v
            if len(self.pe_data)>lasti:
                ret.extend([0 if x == 0 else x ^ 0xff for x in self.pe_data[lasti:len(self.pe_data)]])
        elif mode=='zero':
            for (k,v) in dict(self.nas).items():
                ret.extend([0] * (k-lasti))
                ret.extend(self.pe_data[k:k+v])
                lasti=k+v
            if len(self.pe_data)>lasti:
                ret.extend([0] * (len(self.pe_data)-lasti))
        else:
            raise ValueError("mode unknown")
        return ret

    def scan(self):
        """
        This function calculates the non-attack space.

        Parameters:
            self (object): The instance of the class.
        
        Returns:
            None
        """
        if self.nas==None:
            return
        start_time = time.perf_counter()
        self.nas,times=self._scanning()
        end_time = time.perf_counter()
        sizeno=0
        self.nas=sorted(self.nas.items())
        deletekey=0
        for i in range(len(self.nas)):
            count=i-deletekey
            if i<len(self.nas)-1:
                current_key, current_value = self.nas[count]
                next_key, next_value = self.nas[count + 1]
                if current_key + current_value > next_key:
                    self.nas[count] = (current_key,next_key-current_key)
            else:
                last_value, last_key = self.nas[count]
                if last_value+last_key>len(self.pe_data):
                    del self.nas[count]
                    deletekey+=1
                    continue
            current_key, current_value = self.nas[count]
            if current_value<=0:
                del self.nas[count]
                deletekey+=1
            elif current_key>len(self.pe_data):
                del self.nas[count]
                deletekey+=1
        for i in range(len(self.nas)):
            _, value = self.nas[i]
            sizeno+=value
        self.multiple_data=[(end_time - start_time) * 1000]+times+[len(self.pe_data)-sizeno]
